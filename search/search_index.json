{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Index","text":"<p>This is just me messing with mkdocs when I have free time, but I'll try to post interesting stuff.</p> <p>I like using hotkeys, hacks and tricks to make me (feel) more efficient.</p>"},{"location":"bash_hotkeys/","title":"Bash hotkeys and tricks","text":"<p>These are my most-used hotkeys and tricks with the command line.</p> <p>Bash has a lot of functionality (the man pages are literally 6500+ lines), with hotkeys, aliases and shortcuts, but much of it is not really more efficient than using the mouse or typing stuff manually, unless you are in an environment where you for example don't have the mouse, or the terminal is very slow.</p> <p>This is a collection of the hotkeys I've actually internalised and helps me be (or at least feel) more efficient in a \"normal\" environment.</p> <p>They may seem like tiny gains (and maybe they are), but it adds up when you constantly save a few seconds by avoiding:</p> <ul> <li>typing long words or symbols</li> <li>backtracking because of typos</li> <li>tiny frustrations</li> </ul>"},{"location":"bash_hotkeys/#completion","title":"Completion","text":"<p>Hotkeys that makes the shell do more of the typing for you.</p>"},{"location":"bash_hotkeys/#tab","title":"Tab","text":"<p>Goes without saying for many people, but it is my most used key by far. I probably use this between every 5 other keystrokes on average, just for good measure. It never hurts, sometimes does nothing, mostly helps. Single-tap it to autocomplete unambigiously, double-tap it to list alternatives. It:</p> <ul> <li>completes file paths</li> <li>helpfully enters the slash character for you in path names</li> <li>completes environment variable names</li> <li>completes commands and command arguments (if this doesn't work, make sure you have the   bash-completion package installed).</li> <li>hints at availably command arguments (note that it might not be 100% accurate or complete, it   depends on the content of the bash-completion script for the specific command)</li> </ul> <p>Tip</p> <p>It is possible to create custom completion files for your custom scripts. That is out of scope for this article, but you'll find good resources on it elsewhere.</p>"},{"location":"bash_hotkeys/#alt","title":"Alt+.","text":"<p>Probably my second most used combination. Inserts the last argument from the previous command.</p> <p>This might sound obscure and a bit silly, but is surprisingly good, because of how arguments on the command line is usually structured (e.g. filename goes last).</p> <p>For example:</p> <pre><code>mkdir -p my_directory/with_the/longest-name_possible # make a nested directory\ncd [alt+.] # navigate to the newly created directory\n# or\nls -l myfile # list a file\ncp [alt+.] [alt+.].bak # make a backup of the file\n# or\nvim myscript.sh # edit a file\n./[alt+.] # execute the script you just edited\ngit add [alt+.] # stage it with version control\n</code></pre> <p>You can also tap it multiple times to get the last argument from the next most recent command, etc.</p> <p>For example, for the following history:</p> <pre><code>~ $ history\n(...)\n1234 vim test.sh\n1235 ls -l\n1236 echo test1 test2\n</code></pre> <ul> <li>First Alt+. inserts <code>test2</code></li> <li>Second Alt+. inserts <code>-l</code></li> <li>Third Alt+. inserts <code>test.sh</code></li> <li>etc.</li> </ul> <p>Tip</p> <p>You can also use Alt+0 then Alt+.</p> <p>A variation of the Alt+. hotkey. Will paste the 0th argument of the previous command (which is actually the base command itself!)</p> <p>It also works with other numbers than 0, but keeping track of which parameter has which index gets difficult and is error-prone, so I find it is mostly its better to copy-paste or write it manually at that point. <code>0</code> (first) and <code>.</code> (last) is easy to keep track of.</p> <p>Useful when you have a command that you need to run more than once, but it is difficult to write or shares the first letters with other commands, making Tab completion less effective:</p> <ul> <li><code>firewall-cmd --add-port=123/udp</code> then <code>firewall-cmd --reload</code>. Last command becomes:   (<code>[alt+0][alt+.] --reload</code>)</li> <li><code>systemctl status myservice</code> then <code>systemctl restart myservice</code>. Last command becomes:   (<code>[alt+0][alt+.] restart [alt+.]</code>)</li> </ul> <p>Also useful when you want to use the man page for the last command, like <code>man [alt+0][alt+.]</code></p>"},{"location":"bash_hotkeys/#ctrld","title":"Ctrl+D","text":"<p>Basically runs the <code>exit</code> command when your prompt is empty. If you've started writing something in the terminal, this hotkey does nothing.</p> <p>It will let you:</p> <ul> <li>Exit out of your <code>sudo -i</code> shell</li> <li>log out your current serial or SSH session</li> <li>quit your interactive Python interpreter</li> <li>exit out of your mysql client shell</li> <li>end your tmux session</li> <li>and probably much more</li> </ul> <p>without writing the exit commands explicitly.</p>"},{"location":"bash_hotkeys/#ctrlr","title":"Ctrl+R","text":"<p>Reverse command search.</p> <ul> <li>You know what your command is, but you don't feel like typing it all.</li> <li>You remember that you need to export a variable, but you don't remember the exact details.</li> <li>You just want to quickly re-run the last <code>vim</code> command without scrolling through the history   with Up.</li> </ul> <p>Just use Ctrl+R, then search for something unique to your command.</p> <p>Didn't find it on the first try? Just run Ctrl+R again for the next match.</p> <p>Mistyped it? Use Ctrl+C and try again.</p> <p>Want to edit it? Use Ctrl+A or Ctrl+E when you've found it (more info on these below).</p>"},{"location":"bash_hotkeys/#_1","title":"<code>!!</code>","text":"<p>This basically just means \"the entire last command\". I've found about two uses for it, but I use them pretty often:</p> <p><code>sudo !!</code> - Repeat the last command, but with sudo</p> <p><code>watch !!</code> - Run the last command over and over automatically to watch for changes.</p> <p>Tip</p> <p>There are a lot of these \"Event designators\", starting with <code>!</code>, but this is the one I actually use. You can also use <code>!123</code> for the 123rd entry in your bash history, <code>!-1</code> for the latest minus 1 command, etc. The issue is that you won't know for sure what the command represents until you either run it, or expand it with Esc Ctrl+E.</p>"},{"location":"bash_hotkeys/#editing","title":"Editing","text":"<p>Commands to make changes to the current work-in-progress command and terminal output.</p>"},{"location":"bash_hotkeys/#ctrll","title":"Ctrl+L","text":"<p>Clears the screen, giving you a fresh start without needing to hold Enter forever.</p> <p>Why not just use <code>clear</code>?</p> <ul> <li>If you're in the middle of writing something in the prompt, that will be preserved.</li> <li>Also Ctrl+L is faster.</li> </ul>"},{"location":"bash_hotkeys/#ctrla-and-ctrle","title":"Ctrl+A and Ctrl+E","text":"<p>To move the cursor to the start (Ctrl+A) and end (Ctrl+E) of the current line.</p>"},{"location":"bash_hotkeys/#ctrlu","title":"Ctrl+U","text":"<p>Cuts/removes anything to the left of the cursor.</p> <p>Less used, but the opposite is Ctrl+K which cuts/removes anything to the right of the cursor.</p>"},{"location":"bash_hotkeys/#ctrly","title":"Ctrl+Y","text":"<p>Will paste whatever you've last cut with Ctrl+U.</p> <p>A very useful combination is Ctrl+E Ctrl+U, which removes the entire line in your prompt. Now you can run another command, maybe an <code>ls</code> command to ensure you are doing the right thing, before pasting the other command back with Ctrl+Y and running it.</p>"},{"location":"bash_hotkeys/#ctrlw","title":"Ctrl+W","text":"<p>Cuts/removes one word at the time, to the left. Note that if you run multiple Ctrl+W commands without doing something else in between, the words will be added to the paste buffer, so that when you run Ctrl+Y later, all the words you deleted with Ctrl+W sequentially will be pasted back.</p> <p>I use it mainly to remove chunks of the prompt quickly though.</p>"},{"location":"bash_hotkeys/#ctrls-and-ctrlq","title":"Ctrl+S and Ctrl+Q","text":"<p>You probably used Ctrl+S before by accident, \"freezing\" your terminal. It can be unfrozen with Ctrl+Q.</p> <p>But it can be used intentionally too, for example if you want to highlight/copy something before some other output scrolls it away, or if you just want an extra second to read whatever the output says.</p> <p>Depending on your terminal emulator, multiplexer, line history, etc. you might be able to scroll back up and get it later, but why wait when you can just pause and do it right now?</p>"},{"location":"bash_hotkeys/#alt-left-and-right","title":"Alt Left and Right","text":"<p>To jump word-by-word instead of letter-by-letter through your current command.</p>"},{"location":"bash_hotkeys/#ctrlx-ctrle","title":"Ctrl+X Ctrl+E","text":"<p>Opens an editor (determined by the <code>EDITOR</code> and <code>VISUAL</code> environment variable), including whatever you've already wrote on the prompt. Very useful for commands with many parameters like complex curl commands.</p> <p>Save and quit to execute it, quit without saving to cancel it.</p> <p>Tip</p> <p>If you get an error like <code>bash: emacs: command not found...</code>, that means you haven't set the <code>EDITOR</code> or <code>VISUAL</code> variable, defaulting it to emacs. Set it with <code>export EDITOR=vim</code> or whatever you prefer, and add it to your <code>~/.bashrc</code> to make it permanent.</p>"},{"location":"bash_hotkeys/#directory-navigation","title":"Directory navigation","text":""},{"location":"bash_hotkeys/#cd","title":"<code>cd</code>","text":"<p>Navigates to your home folder, the same way <code>cd ~</code>, <code>cd $HOME</code> and <code>cd /home/$USER/</code> does.</p>"},{"location":"bash_hotkeys/#cd-","title":"<code>cd -</code>","text":"<p>Will navigate to the previous folder you were in. Very nice when you need to jump to another folder temporarily, then go back.</p> <pre><code>cd ../my/other/folder\nls -l\ncd - # to go back to where you were\n</code></pre>"},{"location":"bash_hotkeys/#cd-foo","title":"<code>cd ~foo</code>","text":"<p>Go the the home folder of the <code>foo</code> user. Mostly useful when logged in as <code>root</code>.</p> <p>This is just a nice little shortcut when your home folder is in <code>/home</code> but very useful if you don't know where the home folder is.</p>"},{"location":"mkdocs_test/","title":"Oves test page","text":""},{"location":"mkdocs_test/#title","title":"Title","text":"<p>Note</p> <p>Testing callout blablablablabalabl</p> <p>HTTP</p>"},{"location":"mkdocs_test/#sub-title","title":"Sub-title","text":"lol1 lol2 lol3 blab fooo bar"},{"location":"mkdocs_test/#sub-sub-title","title":"Sub-sub-title","text":"<p>bold font and italic font, maybe even underlined font</p> <p>strikethrough? </p>"},{"location":"mkdocs_test/#subsubsubsubsubsub","title":"subsubsubsubsubsub","text":"<p>This is just regular text, testing newline logic</p> <p>HTTP</p> <p>for this flavor of markdown</p> <p>I like <code>inline code</code>; I can even have syntax highlighting for it, like <code>some_key: value_pair</code></p> <pre><code>code:\n  blocks:\n    - are\n    - fun\nand:\n  annotations: are # possible\n  like: here # (1)!\n</code></pre> <ol> <li>Oveerkul</li> </ol> <p>BBQ</p> <pre><code>with mkdocs\nit is possible to\nhighlight certain lines\nin a text, for example\nlike i have done here\nlol foo wtf bbq\nblablablablablablabla\n</code></pre> <p>If you are running windows hotkeys on a linux server, expect trouble...</p> <p>For example, to spice up life, run Ctrl+Alt+Del in a linux serial console</p>"},{"location":"ssh_dynamic_forward/","title":"Dynamic forwarding using Firefox MultiAccount containers","text":""},{"location":"ssh_dynamic_forward/#intro","title":"Intro","text":"<p>Setting up Dynamic forwarding basically allows you to say \"Hey Firefox/browser, please navigate to this hostname and port, but do it as if you were actually running on the remote server I just SSH'ed into.\"</p> <p>This is very useful when you want access to a Web UI for a server that you can normally only reach via another server using SSH. It can easily be set up by specifying a port for Dynamic Forwarding (for example <code>:9999</code>), and then editing your proxy settings to point to something like <code>localhost:9999</code>.</p> <p>Now you can enter a url like https://my-service-web-ui:4321 in Firefox and it will navigate to it via the internal server!</p> <p>However, this server is (of course) securely installed inside a restricted network, and cannot reach public URLs. So when you try to do some troubleshooting by navigating to https://duckduckgo.com, your Firefox server might not be able to reach it, and your SSH terminal will get spammed with <code>Connection refused</code>, <code>Access Denied</code>, or similar, depending on your network and proxy settings.</p> <p>Separating the different proxy configurations into different Multi-Account containers will allow you to just open a tab in a container that represents where your firefox should be connecting from.</p> <p>You would use it simply by opening a new tab in a specific container, then navigate to your service, like this:</p> <pre><code>graph LR\n  A{Firefox}\n  A --&gt;|using container| B(None) --&gt;|https:443| H&gt;google.com]\n  A --&gt;|using container| C(Server1)\n  C --&gt;|https:443| I&gt;internal service1]\n  A --&gt;|using container| D(Server2)\n  D --&gt;|https:8001| J&gt;internal service2]</code></pre> <p>But it behind the scenes it actually goes via another server, and would look more like this:</p> <pre><code>graph LR\n  A{Firefox}\n  A --&gt;|using container| B(None) --&gt;|https:443| H&gt;google.com]\n  A --&gt;|using container| C(Server1) -.-&gt;|ssh| X[Internal server1]\n  X --&gt;|https:443| I&gt;internal service1]\n  A --&gt;|using container| D(Server2) -.-&gt;|ssh| Y[Internal server2]\n  Y --&gt;|https:8001| J&gt;internal service2]\n\n  C --&gt;|SOCKS| X\n  D --&gt;|SOCKS| Y</code></pre> <p>Side note!</p> <p>Multi-account containers are also great to set up regardless of proxying/forwarding, for example if you:</p> <ul> <li>have to log into multiple cloud consoles for AWX/Azure or others which use Single Sign-on, and   you don't like having to log in and out or using Private browsing to achieve it.</li> <li>want to have something like a Facebook, Discord or Youtube account logged in, but you don't want   to mix work and personal profiles.</li> </ul> <p>This setup has worked really well for me, you might want to give it a try!</p>"},{"location":"ssh_dynamic_forward/#setup","title":"Setup","text":""},{"location":"ssh_dynamic_forward/#ssh-part","title":"SSH part","text":"<p>Set up your SSH config with Dynamic forwarding, if necessary using jumphosts, in your <code>~/.ssh/config</code>:</p> <pre><code>Host jumphost\n    Hostname some_hostname\n    User username\n    Port 22\n    IdentityFile ~/.ssh/id_ed25519_blablabla\n\nHost final_destination\n    Hostname some_other_hostname\n    ProxyJump jumphost\n    User username\n    DynamicForward 9999 # &lt;-- This is the important part\n    LogLevel error # (1)!\n\nHost another_destination\n    Hostname some_other_other_hostname\n    User firstlastname\n    DynamicForward 8888 # &lt;-- You can add as many as you want/need with different ports\n    LogLevel error\n</code></pre> <ol> <li>Add this to supress \"Connection refused\" messages that appear every time    you try to access a website that cannot be reached through the SOCKS proxy.</li> </ol>"},{"location":"ssh_dynamic_forward/#firefox-part-optional-but-recommended","title":"Firefox part (Optional but recommended)","text":"<p>In Firefox, install the following extensions:</p> <ul> <li>Multi-Account Containers</li> <li>Sidebery (or any other plugin that lets to specify SOCKS5 proxy per container)</li> </ul> <p>Create one container for each relevant Dynamic Forwarding server.</p> <p>Add <code>localhost:9999</code> (or whichever port you specified in your SSH config) to the Multiaccount-container of your choice. You can create multiple containers too, if you need access to services in multiple separated zones.</p> <p>Done!</p> <p>You can now browse whatever you would have access to on the remote server, as long as you:</p> <ol> <li>Have opened an SSH session to it</li> <li>Open it using the relevant MultiAccount container</li> </ol>"}]}